
;****************************************************
; Global constants
;****************************************************

; RReteType: rete node type
(defconst RRT_ROOT    0)
(defconst RRT_NAME    1)
(defconst RRT_VAR     2)
(defconst RRT_CONST   3)
(defconst RRT_ALPH0   4)
(defconst RRT_ALPH1   5)
(defconst RRT_EXPR0   6)
(defconst RRT_EXPR1   7)
(defconst RRT_EXPR2   8)
(defconst RRT_EXPR3   9)
(defconst RRT_EXPR4  10)
(defconst RRT_BETA0  11)
(defconst RRT_BETA1  12)
(defconst RRT_BETA2  13)
(defconst RRT_BETA3  14)
(defconst RRT_RULE   15)
(defconst RRT_WORK   16)

(defconst ATTR_RETE_TYPE rete-type)
(defconst ATTR_ENTRY_LEN entry-len)

; RReteStatus: rete count type
(defconst RRS_DEFINE 0)
(defconst RRS_REASON 1)
(defconst RRS_ASSUME 2)
(defconst RRS_REMOVE 3)
(defconst RRS_FIXED  4)
(defconst RRS_TEMP   5)

(defconst RRS_ALL_STATUS '(RRS_DEFINE RRS_REASON RRS_ASSUME RRS_REMOVE RRS_FIXED RRS_TEMP))

; RReteType: rete node type
(defconst RETE_PRIORITY_DEFAULT  99)
(defconst RETE_PRIORITY_MAXIMUM  499)

; RRunState: rete run state
(defconst RRUN_STATE_COMPLETED completed)
(defconst RRUN_STATE_FAILED    failed)
(defconst RRUN_STATE_HALTING   halting)
(defconst RRUN_STATE_RUNNABLE  runnable)
(defconst RRUN_STATE_RUNNING   running)
(defconst RRUN_STATE_PARTIAL   partial)

;****************************************************
; Common utilies
;****************************************************

(alias add-stmt ->)

(defun size-of ((?m model)) (return (size-of-model ?m)))

(defmacro list-with-state (?list ?state)
    (foreach (?e ?list)
        (if (not (equal (state-of ?e) ?state))
            (continue)) 
        (return ?e))
)
        
(defmacro list-without-state (?list ?state)
    (foreach (?e ?list)
        (if (equal (state-of ?e) ?state)
            (continue)) 
        (return ?e))
)

(defmacro list-rule (?m) (rete-node-of ?m RRT_RULE))

(defun get-rule ((?m model) (?name string))

    (defvar ?nodes (rete-node-of ?m RRT_RULE ?name))
    (case (size-of ?nodes)
        (0 (return nil))
        (1 (return (get ?nodes 0)))
        (? (throw bad-model ("duplicated rule node found: " ?name)))
    )
)

(defun get-root-rete-node ((?m model) (?len int))

    (defvar ?nodes (rete-node-of ?m RRT_ROOT ?len))
    (case (size-of ?nodes)
        (0 (return nil))
        (1 (return (get ?nodes 0)))
        (? (throw bad-model ("duplicated root node found: " ?name)))
    )
)

(defun get-named-rete-node ((?m model) (?name string))

    (defvar ?nodes (rete-node-of ?m RRT_NAME ?name))
    (case (size-of ?nodes)
        (0 (return nil))
        (1 (return (get ?nodes 0)))
        (? (throw bad-model ("duplicated namded node found: " ?name)))
    )
)

(defun rete-type-of (?n) (return (get-attribute $(value-of ?n) ATTR_RETE_TYPE)))
(defun entry-length-of (?n) (return (get-attribute $(value-of ?n) ATTR_ENTRY_LEN)))
(defun rete-valid-entry-of (?n) 
    (return (+  (rete-entry-count-of ?n RRS_DEFINE)
                   (rete-entry-count-of ?n RRS_REASON)
                   (rete-entry-count-of ?n RRS_ASSUME)
                   (rete-entry-count-of ?n RRS_FIXED)
                   (rete-entry-count-of ?n RRS_TEMP))
               ))

;****************************************************
; Constraint utilies
;****************************************************

(defun init_cst_rule ((?m model))

    (if (equal ?m::?cst-init true)
        (return))
            
    (add-rule "CST01" ?m::$cst$ 
        if  $cst_type$:'(?node ?index ?type1) $cst_type$:'(?node ?index ?type2) (not (equal ?type1 ?type2)) 
        do 
            (defvar ?msg (+ "conflict-type-constraint:'(" ?node " " ?index " " ?type1 " " ?type2 ")"))
            (-> $invalid_constraint$:'(?msg))
    )
    
    (add-rule "CST02" ?m::$cst$ if $cst_type$:'(?node ?index ?type1) do (-> $cst_node$:'(?node type)))
    (add-rule "CST03" ?m::$cst$ if $cst_max$:'(?node ?index ?value)  do (-> $cst_node$:'(?node max)))
    (add-rule "CST04" ?m::$cst$ if $cst_min$:'(?node ?index ?value)  do (-> $cst_node$:'(?node min)))

    (setq ?m::?cst-init true)
)

(defun add_cst_constraint_type ((?m model) (?node string) ?index ?type)
    (init_cst_rule ?m)        
    (add-stmt ?m $cst_type$:'(?node ?index ?type))
    (query-stmt ?m::$cst$ '(?c) from $invalid_constraint$:'(?c) 
            do (remove-stmt ?m $cst_type$:'(?node ?index ?type)) 
               (throw add-constraint-fail (+ "type-constraint:'(" ?node " " ?index " " ?type "), " ?c))  limit 1)
    (return (add-constraint ?m (to-named-list ?node '(?...)) (type ?type on (to-atom (+ "?" ?index)))))
)

(defun remove_cst_constraint_type ((?m model) (?node string) ?index ?type)
    (init_cst_rule ?m)
    (defvar ?drop-stmt-list (remove-stmt ?m $cst_type$:'(?node ?index ?type)))
    (if (is-empty ?drop-stmt-list) (return '()))
    (return (remove-constraint ?m (to-named-list ?node '(?...)) (type ?type on (to-atom (+ "?" ?index)))))
)

(defun add_cst_constraint_max ((?m model) (?node string) ?index (?value int))
    (init_cst_rule ?m)        
    (add-stmt ?m $cst_max$:'(?node ?index ?value))
    (query-stmt ?m::$cst$ '(?c) from $invalid_constraint$:'(?c) 
            do (remove-stmt ?m $cst_max$:'(?node ?index ?value)) 
               (throw add-constraint-fail (+ "max-constraint:'(" ?node " " ?index " " ?value "), " ?c))  limit 1)
    (return (add-constraint ?m (to-named-list ?node '(?...)) (max ?value on (to-atom (+ "?" ?index)))))
)

(defun remove_cst_constraint_max ((?m model) (?node string) ?index (?value int))
    (init_cst_rule ?m)        
    (defvar ?drop-stmt-list (remove-stmt ?m $cst_max$:'(?node ?index ?value)))
    (if (is-empty ?drop-stmt-list) (return '()))
    (return (remove-constraint ?m (to-named-list ?node '(?...)) (max ?value on (to-atom (+ "?" ?index)))))
)

(defun add_cst_constraint_min ((?m model) (?node string) ?index (?value int))
    (init_cst_rule ?m)        
    (add-stmt ?m $cst_min$:'(?node ?index ?value))
    (query-stmt ?m::$cst$ '(?c) from $invalid_constraint$:'(?c) 
            do (remove-stmt ?m $cst_min$:'(?node ?index ?value)) 
               (throw add-constraint-fail (+ "min-constraint:'(" ?node " " ?index " " ?value "), " ?c))  limit 1)
    (return (add-constraint ?m (to-named-list ?node '(?...)) (min ?value on (to-atom (+ "?" ?index)))))
)

(defun remove_cst_constraint_min ((?m model) (?node string) ?index (?value int))
    (init_cst_rule ?m)        
    (defvar ?drop-stmt-list (remove-stmt ?m $cst_min$:'(?node ?index ?value)))
    (if (is-empty ?drop-stmt-list) (return '()))
    (return (remove-constraint ?m (to-named-list ?node '(?...)) (min ?value on (to-atom (+ "?" ?index)))))
)

(defun add_cst_constraint_one_of ((?m model) (?node string) ?index (?value list))
    (init_cst_rule ?m)        
    (add-stmt ?m $cst_one_of$:'(?node ?index ?value))
    (query-stmt ?m::$cst$ '(?c) from $invalid_constraint$:'(?c) 
            do (remove-stmt ?m $cst_one_of$:'(?node ?index ?value)) 
               (throw add-constraint-fail (+ "one-of-constraint:'(" ?node " " ?index " " ?value "), " ?c))  limit 1)
    (return (add-constraint ?m (to-named-list ?node '(?...)) (one-of ?value on (to-atom (+ "?" ?index)))))
)

(defun remove_cst_constraint_one_of ((?m model) (?node string) ?index (?value list))
    (init_cst_rule ?m)        
    (defvar ?drop-stmt-list (remove-stmt ?m $cst_one_of$:'(?node ?index ?value)))
    (if (is-empty ?drop-stmt-list) (return '()))
    (return (remove-constraint ?m (to-named-list ?node '(?...)) (one-of ?value on (to-atom (+ "?" ?index)))))
)



;;(defun add_cst_constraint_index_1 ((?m model) (?node string) ?index ?cst_type)
;;    (init_cst_rule ?m)        
;;    (add-stmt ?m $cst_index_1:'(?node ?index ?cst_type))
;;    (query-stmt ?m::$cst$ '(?r ?c1 ?c2) from $invalid_constraint$:'(?r ?c1 ?c2) 
;;            do (remove-stmt ?m $cst_type$:'(?node ?index ?type)) 
;;               (throw add-constraint-fail (+ ?r ?c1 ?c2))
;;    limit 1)
;;)

